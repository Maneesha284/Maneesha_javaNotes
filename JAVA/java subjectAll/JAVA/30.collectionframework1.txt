Set(I):-
====

	collection(1.2)
	     |
	set(I)(1.2)
	   /       \
HashSet(1.2)		SortedSet(I)(1.2)
    |			      |
LinkedHashSet(1.4)		NavigableSet(I)(1.6)
			      |
			TreeSet(1.2)

*group of individual objects as a single enitity
*duplicates not allowed insertion orderis not preserved.
*set(I) doesn't contain any new methods so we have to use only collection(I) methods.
************************************************************************************************************************************
HashSet:-
======
1.The underlying Data Structure is Hashtable.
2.Duplicates not allowed. If we are trying to insert duplicates, we won't get any compiletime or runtime error. add() method simply returns false.
3.Insertion order is not preserved and all objects will be "inserted based on hash-code" of objects.
4.Hetrogeneous objects are allowed.
5.null insertion is possible.
6.implements serializable and clonable interfaces but not RandomAccess.
7.HashSet is the best choice, If our frequent operation is serach operation.

Constructors:-
HashSet, LinkedHashSet, Hashtable, HashMap, IdentityHashMap, WeakHashMap

1. HashSet h=new HashSet();
creates an empty HashSet with default capacity- 16

2. HashSet h=new HashSet(int initialCapacity);
creates an empty HashSet with specified initialCapacity and default Ratio- 0.75

3. HashSet h=new HashSet(int initialCapacity, float loadFactor);
cretes an empty HashSet with specified initialCapacity and and Speicified Load factor(fill ratio)

4. HashSet h=new HashSet(Collection c);
For inter conversion b/w Collection Object.

import java.util.HashSet;
class HashSet11 {
       public static void main(String args[])  {
	HashSet h=new HashSet();
	h.add("t");
	h.add("s");
	h.add("m");
	h.add("i");
	System.out.println(h.add("m"));
	System.out.println(h);
         }
}	

NOTE:Load Factor/ Fill Ratio:-
======================
After loading the how much factor, a new HashSet Object will be created, that factor is called as Load Factor or Fill Ratio.
************************************************************************************************************************************
LinkedHashSet:-
===========
HashSet(1.2)		
    |			     
LinkedHashSet(1.4)

It is exactly same as HashSet except the following difference
1.The underlying Data Structure is Hashtable+LinkedList.
2.Insertion order is preserved
3.LinkedHashSet(1.4) version

import java.util.LinkedHashSet;
class LinkedHashSet1 {
       public static void main(String args[])  {
	LinkedHashSet h=new LinkedHashSet();
	h.add("t");
	h.add("s");
	h.add("m");
	h.add("i");
	System.out.println(h.add("m"));
	System.out.println(h);
         }
}	
o/p:-
flase
[t, s, m, i]

NOTE:LinkedHashSet is the best choice to develop cache based applications, where duplicates not allowed and insertion order must be preserved.
************************************************************************************************************************************
SortedSet(I):-
=========
Set(I)
  /\
   |
SortedSet(I)
 *If u want group of individual objects according to some sorting order and duplicates are not allowed.

SortedSet specific methods:-
10 20 30 40 50 60 70 80
1.Object first()-->10

2.Object last()-->20

3.SortedSet headSet(Object o)
less than particular object 
headSet(30)--->20

4.tailSet(Object o)
greaterthan than particular object 
tailSet(50)--->60

5.subSet(Object o1, Object o2)
returns  the sortedset whose elements are >=o1 and <o2
subSet(30, 60)-->30, 40, 50 

6.comparator():-
returns comparator object which describe underlying sorting technique
default natural sorting order:-(no-Ascending order for string-Alphabetical order)--->null return

NOTE:-we can apply the above methods only on SortedSet implmented class Objects. That is on the TreeSet Object.
************************************************************************************************************************************
TreeSet:-
=======
1.The underlying Data Structure for TreeSet is balanced Tree.
2.Duplicates not allowed. If we are trying to insert duplicates, we won't get any compiletime or runtime error. add() method simply returns false.
3.Insertion order is not preserved and all objects will be inserted based according to some sorting order.
4.Hetrogeneous not allowed.(RE: ClassCastException)
5.null insertion is possible(only one time).

Constructors:-
1.TreeSet t=new TreeSet();	
default natural sorting order
2.TreeSet t=new TreeSet(Comparator c);
Customized sorting order(name, sal tec..) 
3.TreeSet t=new TreeSet(Collection c);
any Collection object(an equivalent TreeSet Object)
4.TreeSet t=new TreeSet(SortedSet s);

import java.util.TreeSet;
class TreeSet11 {
       public static void main(String args[])  {
	TreeSet t=new TreeSet();
	t.add("C");
	t.add("b");
	t.add("a");
	t.add("B");
	t.add("e");
	t.add("M");
	t.add("101"); 	//String
	//t.add(new Integer(10));	//ClassCatException
	//t.add(null);	//NullPointerException
	System.out.println(t);
         }
}	
o/p:-
[101, B, C, M, a, b, e]

null acceptance(TreeSet):-
==================
*For empty TreeSet as the first element null insertion is possible But after inserting that null if we are trying to insert any another element
we will get NullPointerExcepion
*For Non empty TreeSet if we are trying to insert Null then we will get NullPointerException.

*****************************************
*************pending(TreeSet)**************
*****************************************
************************************************************************************************************************************
Diff b/w Comparable(I) and Comparator(I) :-
============================
	Comparable
1.It is meant for Default sorting order.

2.Present in java.lang package

3.It defines only one method compareTo()

4.All wrapper classes and String class implement comparable(I)

	Comparator
1.It is meant for Customized sorting order.

2.Present in java.util package

3.It defines 2 method compare() and equals()

4.Only one implemented classes of comparator are Collator and RuleBasedCollator

Comparsion of Set(I) implemented classes

Poperty				HashSet			LinkedHashSet			TreeSet

1.underlying DS			Hashtable		Hashtable+LinkedList		Balanced Tree

2.Inserton order		Not preserved		preserved			Not Applicable

3. Sorting order		Not Applicable		Not Applicable			Applicable

4.Hetrogeneous objects		Allowed			Allowed				Not Allowed

5.Duplicate objects		Not Allowed 		Not Allowed 			Not Allowed

6.Null Acceptance 		Allowed(only once)	Allowed(only once)		Allowed(only once)For empty TreeSet

====================================================================================================================================================
Map interface methods:-
Entry -->Each key-value pair
1. Object put(Object key,Object value):-
To add one key-value pair to the map
If the key is already present then old value will be replaced with new value and return old value.


Map m =new HashMap(Integer,String);
m.put(101,"anu"); 
m.put(102,"nithya");
m.put(103,"laxmi");
m.put(101,"kiran");   //returns "anu"

output:-
101-kiran
102-nithya
103-laxmi

2.void putAll(Map m)-->Add group of key-value pairs.

3.Object get(Object key)-->returns the value associated with specified key

4.Object remove(Object key)-->remove key-value pair associated with specified key

5.boolean containsKey(key)-->Whether this particular key is available or not

6.boolean containsValue(value)-->Whether this particular value is available or not

7.boolean isEmpty()-->Whether this empty or not

8.int size()-->How many key-value pairs are there

9.void clear()-->all key-value pairs removed

Collection views of Map(Methods):-

10.Set keySet()--->To get all keys

11.Collection values()-->To get all values

12.Set entrySet()-->To get key-value pair set

Entry(Interface):-
A Map is a group of k-v pairs and each k-v pair is called an entry. Hence map is considred as collection of entry objects.
without existing map object there is no chance of existing entry object. Hence entry interfce is define inside map interface.
interface Map{
	interface Entry{
		Object getKey()
		Object getValue()
		Object setValue(Object newobj)
		//These methods are entry specific methods and we can apply ony on entry object.
	}
}

========================================================================================================================================================
HashMap:-
*Th undelying data structure is Hashtable.
*Insertion order is not preserved and it is based on hashcode of keys.
*Duplicate keys not allowed but values can be duplicated.
*Hetrogeneous objects are allowed for both key nad value.
*null is allowed for key(only once), null is allowed for values(any no.of times)
*HashMap implements serializable and Clonable interface but not RandomAccess.
*HashMap is the best choice if our frequent operation is search operation.

1)HashMap m=new HashMap(); //creates an empty HashMap object with default initailcapcity 16 and default fillratio 0.75

2)HashMap m=new HashMap(int initailcapacity);  //creates an empty HashMap object with spcified initailcapcity and default fillratio 0.75

3)HashMap m=new HashMap(int initailcapacity,flaot fillratio);

4)HashMap m=new HashMap(Map m);

HashMap internal working.































































































